var after = require("after");

/*
    tester will run the methods of tests for you.
    If any throw errors they will be added to errors
    and if they succeed then the test name will be added to 
    success.

    A test method can take an optional `done` parameter. This 
    function can be called to attach a function of unit tests to
    run when your test is "done". You can then call done later
    in an asynchronous fashion when your tests are done to run
    those assertions.

    example:

        tester({
            "sync test": function () {
                assert("aweshum!");
            },
            "async test": function (done) {
                var fail = false;
                done(function () {
                    assert(fail === "win");
                });
                setTimeout(100, function () {
                    fail = "win";
                    done(); 
                });
            }
        });

    @param Object tests - a set of unit test methods
    @param Object hash - an optional hash

        {
            Boolean noReport - a boolean to turn off reporting
            Function cb - a callback to call after async tests are done
        }

    @return Array - Returns a tuple containing success & errors
*/
module.exports = function _tester(tests, hash) {
	var keys = Object.keys(tests);
    var errors = [];
    var success = [];
    var asyncCounter = 0;
    keys.forEach(function (test) {
        var f = tests[test];
        
        if (f.length === 0) {
            try {
                f();
                success.push(test);
            } catch (e) {
                errors.push(e);
            }
        } else {
            var last;
            asyncCounter++;
            f(function _done(v) {
                if (!last) { 
                    last = v; 
                } else if (last) {
                    try {
                        last.apply(this, arguments);
                        success.push(test);    
                    } catch (e) {
                        errors.push(e);
                    } finally {
                        end && end();    
                    }
                }
            });
        }
    });
    var end = after(asyncCounter, function () {
        if (!hash || !hash.noReport) {
            console.log("tests run : " + keys.length);
            console.log("tests succeeded : ", success.length);
            console.log("errors : ", errors.length);
            errors.forEach(function (e) {
                console.dir(e);
                console.log(e.stack);
            });
        }
        hash && hash.cb && hash.cb(success, errors);
    });
    return [success, errors];
};